---
category: 数据库
---

## Mysql与B+树(2)

在[Mysql与B+树(1)](https://yedong666.github.io/blogs/%E6%95%B0%E6%8D%AE%E5%BA%93/2022/02/13/Mysql%E4%B8%8EB+%E6%A0%91(1).html)中我讲了一些自己对Mysql和B+树的理解和思考，捋清楚其底层的逻辑之后，我发现以前许多疑惑的问题或者概念都可以据此一一回答和解决。

### 索引带来的性能提升

我们都知道在数据量达到一定量级时，为表建立合适的索引可以大大提升查询速度，那么其提升的原理是什么呢？

#### 背景

Mysql在查询数据时，不考虑缓存之类的其它影响，大部分查询都是需要通过主键索引来获取到数据或是对应数据指针。主键索引也叫聚簇索引，它是由Mysql在表的创建之初的被生成的。

除了聚簇索引以外，我们以可以根据自己的需要创建索引，其中的元素可以是每个元组的一个字段，也可以是多个字段；有了这些索引我们在进行和这些字段相关的查询时，可以通过我们建立的这个索引树查到对应的主键id，然后再去主键索引树里查找数据。这样做避免了全表扫描，既减少了磁盘IO也减少了CPU执行时间。

#### 一个例子对比全表扫描和根据索引查询

至于什么是全表扫描，上述做法又是如何减少了磁盘IO也减少了CPU执行时间的呢？举一个例子就明白了。

如果我要根据名字在一张表里面查找一个人的身份信息，在没有建立其名字对应的索引以前Mysql会怎么做呢？

假设该表的数据量下，索引树高为3，查找的数据在第k个叶子结点，每个结点的元素个数是m, 在非叶子结点平均遍历的元素个数是a。

则Mysql需要从主键索引树的根结点出发，来到第一个叶子结点，从该结点开始，依次将每个叶子结点对应的数据从磁盘取到内存，由CPU对数据进行遍历判断，直到找出目标数据或者遍历完所有叶子结点对应的所有数据，这就是全表扫描。如果有名字索引，查询流程将会得到大大改善：Mysql从名字索引树根节点出发，只需访问3个结点，便可确定目标数据的主键值，然后访问3次主键索引树的结点即可得到目标数据或其地址。

#### 两者的性能

Mysql每次和磁盘交互的数据大小是16KB，一般来说，它会对应一个结点内的数据，因此每个结点的访问便是一次IO。

那么全表扫描的IO次数至少是大于k+2+p次的：访问了根结点、一个非叶子节点，k个叶子结点，此外还有读取具体数据时的IO，这里设其为p, 其大小取决于每条数据的大小以及遍历的叶子结点元素个数；遍历元素个数是k*m+2*a：两个非叶子结点中遍历的元素个数加上在叶子结点中遍历的元素个数。

而对于走了名字索引的查询，其IO次数为8左右：其只访问了名字索引树的三个结点和主键索引树的三个结点，以及它们对应的最终数据读取，总共只有8次。遍历元素最多只有2m+4a。

计算得到IO次数差为K+P-6，(k-2)m - 2a;	

#### 对比较结果的分析

通过对比结果我可以发现，当K小于一定值的时候，结果会变成负数，即全表扫描性能高于索引查询，这就回答了为什么数据量小的时候创建索引索引反而会降低性能。而当数据达到一定量级的时候K的平均值会非常大，索引查询的优势也就体现出来了。

回表是Mysql中的一个重要概念，许多操作会导致大量无用的回表查询，严重降低查询速度。下面是我由B+树索引出发，对回表操作的一点思考和理解。

